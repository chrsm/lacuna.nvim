import "lsqlite3" as sqlite
import "xmlua" as xmlua

import "lacuna.parser.base" as Base

class Lua extends Base
  new: (db_path) =>
    @db = sqlite.open db_path
    @db\exec @@view

  run_query: (v) =>
    gots = {}
    for r in @db\rows (@@query\gsub "<QUERY_VALUE>", v)
      gots[] = {
        value: r[1]
        type: r[2]
        loc: r[3]
        frag: r[4]
      }

    gots

  get: (file, entries) =>
    -- TODO: remove
    -- i'm assuming other doc sets don't always have the same file,
    -- so it'd be nice to pre-group entries by target file
    -- but i'm not doing that yet
    unless entries[1]
      entries = { entries }

    fp, err = io.open file
    if err
      error "couldn't parse manual: #{ err }"

    doc = fp\read "*a"
      |> xmlua.HTML.parse

    -- wow, now i get why people just embed a fucking browser.
    -- basically, read up until the next hr, h2, or h3. /shrug
    ret = {}
    for i, v in ipairs entries
      c = {}
      for i, v in ipairs doc\search "//a[@name='#{ v.frag }']"
        -- jump up, we're in an h3
        p = v\parent!
        n = p\next!
        while n and (n\name! != "hr") and (n\name! != "h2") and (n\name! != "h3")
          --content = ((n\content!)\gsub "^%s*(.-)%s*$", "%1")

          -- yuck. formatting here is particularly bad.. what to do?
          content = (n\content!)\gsub "\n\n\n", "\n"
          for ln in content\gmatch "([^\n]*)\n?"
            c[] = ln

          n = n\next!

      ret[] =
        name: v.value
        entry: v
        content: c
        search_keys: v.frag

    ret

export default Lua
